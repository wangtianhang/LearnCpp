#version 410 core

// Output
layout (location = 0) out vec4 color;

// Input from vertex shader
in VS_OUT
{
	vec4 shadow_coord;
    vec3 N;
    vec3 L;
    vec3 V;
} fs_in;

// Material properties
uniform vec3 diffuse_albedo = vec3(1, 1, 1);
uniform vec3 specular_albedo = vec3(1);
uniform float specular_power = 30.0;

uniform sampler2D  shadowMap;

float ShadowCalculation(vec4 fragPosLightSpace)
{
    // 执行透视除法
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // 变换到[0,1]的范围
    projCoords = projCoords * 0.5 + 0.5;
    // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)
    float closestDepth = texture(shadowMap, projCoords.xy).r; 
    // 取得当前片元在光源视角下的深度
    float currentDepth = projCoords.z;
    // 检查当前片元是否在阴影中
    float shadow = currentDepth > closestDepth  ? 1.0 : 0.0;

    return shadow;
}

void main(void)
{
    // Normalize the incoming N, L and V vectors
    vec3 N = normalize(fs_in.N);
    vec3 L = normalize(fs_in.L);
    vec3 V = normalize(fs_in.V);
    vec3 H = normalize(L + V);

    // Compute the diffuse and specular components for each fragment
    vec3 diffuse = max(dot(N, L), 0.0) * diffuse_albedo;
	float nh = max(dot(N, H), 0.0);
    vec3 specular = pow(nh, specular_power) * specular_albedo;

    // Write final color to the framebuffer
    color = ShadowCalculation(fs_in.shadow_coord) * vec4(diffuse + specular, 1.0);
	//color = vec4(textureProj(shadow_tex, fs_in.shadow_coord));
	//if(ShadowCalculation(fs_in.shadow_coord) > 0.8)
	//{
	//	color = vec4(1, 0, 0, 1);
	//}
	//else
	//{
	//	color = vec4(0, 1, 0, 1);
	//}
}
