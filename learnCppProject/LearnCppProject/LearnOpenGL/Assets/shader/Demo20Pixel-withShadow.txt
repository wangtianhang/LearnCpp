#version 410 core

// Output
layout (location = 0) out vec4 color;

// Input from vertex shader
in VS_OUT
{
	vec4 shadow_coord;
    vec3 N;
    vec3 L;
    vec3 V;
} fs_in;

// Material properties
uniform vec3 diffuse_albedo = vec3(1, 1, 1);
uniform vec3 specular_albedo = vec3(1);
uniform float specular_power = 30.0;
uniform float bias = 0.005;
uniform ivec2 depthSize;

uniform sampler2D  shadowMap;

//float texture2DCompare(sampler2D depths, vec2 uv, float compare, float bias){
//    float depth = texture2D(depths, uv).r;
//	float shadow = compare - bias> depth  ? 1.0 : 0.0;
//    return 1 - shadow;
//}

//float PCF(sampler2D depths, vec2 size, vec2 uv, float compare, float bias){
//    float result = 0.0;
//    for(int x=-2; x<=2; x++){
//        for(int y=-2; y<=2; y++){
//            vec2 off = vec2(x,y)/size;
//            result += texture2DCompare(depths, uv+off, compare, bias);
//        }
//    }
//    return result/25.0;
//}

float linstep(float low, float high, float v){
    return clamp((v-low)/(high-low), 0.0, 1.0);
}

float VSM(sampler2D depths, vec2 uv, float compare, float bias){
    vec2 moments = texture2D(depths, uv).xy;
    float p = smoothstep(compare - bias, compare, moments.x);
    float variance = max(moments.y - moments.x*moments.x, -0.001);
    float d = compare - moments.x;
    float p_max = linstep(0.2, 1.0, variance / (variance + d*d));
    return clamp(max(p, p_max), 0.0, 1.0);
}

float ShadowCalculation(vec4 fragPosLightSpace, float bias)
{
    // 执行透视除法
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // 变换到[0,1]的范围
    projCoords = projCoords * 0.5 + 0.5;
    // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)
    //float closestDepth = texture(shadowMap, projCoords.xy).r; 
    // 取得当前片元在光源视角下的深度
    //float currentDepth = projCoords.z;
    // 检查当前片元是否在阴影中
	
	//float ret = PCF(shadowMap, depthSize, projCoords.xy, projCoords.z, bias);
	float ret = VSM(shadowMap, projCoords.xy, projCoords.z, bias);
	
    //float shadow = currentDepth - bias> closestDepth  ? 1.0 : 0.0;

    return ret;
}

void main(void)
{
    // Normalize the incoming N, L and V vectors
    vec3 N = normalize(fs_in.N);
    vec3 L = normalize(fs_in.L);
    vec3 V = normalize(fs_in.V);
    vec3 H = normalize(L + V);

    // Compute the diffuse and specular components for each fragment
    vec3 diffuse = max(dot(N, L), 0.0) * diffuse_albedo;
	float nh = max(dot(N, H), 0.0);
    vec3 specular = pow(nh, specular_power) * specular_albedo;

    // Write final color to the framebuffer
	float bias = max(bias * 10 * (1.0 - dot(N, L)), bias);
	float shadow = ShadowCalculation(fs_in.shadow_coord, bias);
    color = shadow * vec4(diffuse + specular, 1.0);
	//color = vec4(textureProj(shadow_tex, fs_in.shadow_coord));
	//if(ShadowCalculation(fs_in.shadow_coord) > 0.8)
	//{
	//	color = vec4(1, 0, 0, 1);
	//}
	//else
	//{
	//	color = vec4(0, 1, 0, 1);
	//}
}
